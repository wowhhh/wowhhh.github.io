---
layout: post
title:  "初识元字符、量词及贪婪"
tags:   元字符 量词 贪婪
date:   2020-07-23 16:42 +0800
categories: [正则表达式]
---

本篇主要内容为学习元字符、量词以及贪婪的基础知识。

## 元字符

https://regex101.com

先说一下正则常见的三种功能：

- 校验数据的有效性
- 查找符合要求的文本
- 对文本进行切割和替换



在正则表达式中，普通字符表示的还是原来的意思，就跟平时做普通的文本查找是一样的。

![image-20200723103133097](https://i.loli.net/2020/09/01/axjgM6WU8Lz51AH.png)

但是正则真正厉害的是能查找符合某个规则的文本。

举个例子：查找下面字符中的数字，使用正则的话，只需要用`\d`即可

```
kah s34dnalnf chjs42aoijhs cdsa cdr
cdt c32at
[aa76a]
dwjo908702\[]q[ewno0wu
4380foehfown
```

![image-20200723103330335](https://i.loli.net/2020/09/01/uMXCt8GDdainTZI.png)

如果在`\d`之后加个`{num}`其中num为数字，就表示出现num次的数字，还是以上述文本为例，使用`\d{3}`

就可以查找出连续出现了三个数字的情况，那相应的简单的匹配手机号码就可以使用`\d{11}`来完成了。

像上述例子中的`\d`和`{3}、{11}`被称之为--元字符(Meta-character)

元字符指的是那些在正则表达式中具有特殊意义的专用字符

### 元字符的分类

- 特殊单字符
- 空白符
- 范围
- 量词
- 断言

#### 特殊单字符

`.`表示换行以外的任意单个字符

`\d`表示任意单个数字 ； `\D`任意非数字

`\w`表示任意单个数字或字母或下划线 ； `\W`任意非数字、字母、下划线

`\s`表示任意单个空白符 ； `\S`任意非空白符

#### 空白符

这里指的是例如空格、换行这种空白符。

`\r` 回车符

`\n`换行符

`\f`换页符

`\t`制表符

`\v`垂直制表符

`\s`任意空白符

####  量词

上面的特殊单字符以及空白符都是只能匹配单个字符，但有时候需要匹配多个，比如：“重复多次”、“至少出现一次”、“最多出现三次”等等。

`*` ：0到多次

`+` ：1到多次

`?`：0到1次 ；比如colou?r 就表示 color和colour两种情况

`{m}`：出现m次

`{m,}`：出现至少m次

`{m,n}`：m到n次

测试：

https://regex101.com/r/PnzZ4k/8

```
1234567890
1
123
```

- Case：`\d+`

  匹配出来三个

  ```
  1234567890
  1
  123
  ```

  

- Case：`\d*`

  匹配出来6个

  ```
  - 1234567890
  - 
  - 1
  - 
  - 123
  - 
  ```

#### 范围

之前说`\d{11}`是可以匹配手机号的，但是呢，这个范围太大了，比如`00000000000`明显就不是手机号，但是还是给匹配上了，所以现在就需要在某个范围里面去查找符合要求的数字。

`|`或，比如`ad|bc`表示ad或者bc

`[...]`，多选一，括号中任意单个元素

`[a-z]`，匹配a到z之间任意单个元素

[^...]，取反，不能是括号中的任意单个元素



### 练习题

> 第 1 位固定为数字 1；
>
> 第 2 位可能是 3，4，5，6，7，8，9；
>
> 第 3 位到第 11 位我们认为可能是 0-9 任意数字。



- 答案 :`1[3-9]\d{9}`

## 量词和贪婪

正则的三种模式

- 贪婪匹配
- 非贪婪匹配
- 独占模式

这些模式会带来什么影响呢？使用不同的模式会有不同的匹配行为，比如会匹配一到多次。

#### 为什么会有贪婪和非贪婪模式

上节中的表示范围的元字符可以简化到此表中：

| 元字符 | 同义表示方法 |                            示例                            |
| :----: | :----------: | :--------------------------------------------------------: |
|   *    |     {0,}     |               正则：ab*；可以匹配a 或者abbb                |
|   +    |     {1,}     |             正则:ab+；可以匹配abbb，不可匹配a              |
|   ?    |    {0,1}     | 正则(\+86-)?\d{11}；可以匹配+86-13800000000或者13800000000 |

##### * 与 +

- `a+`

  ![image-20200723141330480](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723141330480.png)

  ![image-20200723141342210](https://i.loli.net/2020/09/01/rMoqgDyzIaiX846.png)

  从上面的匹配结果看到，就匹配出了一个`aaa`

- `a*`

  ![image-20200723141432894](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723141432894.png)

![image-20200723141439257](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723141439257.png)

从上面的匹配结果看到，`a*`不仅仅匹配得到了aaa，还得到了两个紫色标志处的空白符。

那么问题就来了！

**为什么`*`的匹配会多了空字符呢**

这是因为`*`代表的是匹配0到多次，而匹配0次就是空字符串。但是这也有问题呀，如果匹配0次是空字符串，那为什么`aaa`之间的空字符串没有匹配上？

emmmm

这就是要引入贪婪和非贪婪模式了，这两种模式都必须满足匹配次数的要求才能够匹配上。

贪婪莫斯就是尽可能的进行最长匹配 ； 与之相反，非贪婪模式就是尽可能进行最短匹配。

#### 贪婪、非贪婪、独占模式

##### 贪婪模式（Greedy）

通过上面的学习已经发现表示次数的量词默认是贪婪的了，在贪婪模式下会尽量做最大长度的匹配。

关于`a*`匹配`aaabb`详细的解析过程：

![image-20200723142513771](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723142513771.png)

也就是说贪婪模式做的是：按找字母顺序匹配查找规则，直到**发现第一个不匹配**为止，之前匹配的就作为匹配得到到的内容了。

##### 非贪婪模式(Lazy)

贪婪模式怎么变为非贪婪模式，在量词后面加上英文的问好(`?`)，以上面的例子为例，贪婪模式为`a*`，非贪婪模式为`a*?`

![image-20200723143604010](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723143604010.png)

匹配到了八个结果，五个空字符串和三个`a`

![image-20200723143655325](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723143655325.png)

所以说非贪婪模式就是，按照字母顺序匹配查找规则，只要发现第一个匹配的就输出结果。

- 对比

![image-20200723143839775](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723143839775.png)

**再举一个例子**

查找引号中的单词

```
Case：
"saqwdsajio" sakhdks "iopjoj"ska
kd"kpmnuqvged"dbsqhjb

明显需要匹配的是：
saqwdsajio
iopjoj
kpmnuqvged
```

**贪婪模式**结果

![image-20200723144142001](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723144142001.png)

![image-20200723144244112](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723144244112.png)

**非贪婪模式**结果

![image-20200723144225386](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723144225386.png)

![image-20200723144233911](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/image-20200723144233911.png)

##### 独占模式

要了解独占模式，需要理解什么是回溯，用下面的例子来理解:

> regex = "xy{1,3}z"

> text = "xyyz"

以上述的正则表达式去匹配的话，当匹配玩xyy的时候，因为是贪婪模式，匹配的字符要足够长，也就是要判断到上面规定的3个，但是z的话又匹配不上，所以这个时候正则就会**向前回溯**，吐出当前字符z，接着用正则中的z去匹配。

如果正则用贪婪模式

> regex = "xy{1,3}?z"

由于 y{1,3}? 代表匹配 1 到 3 个 y，尽可能少地匹配。匹配上一个 y 之后，也就是在匹配上 text 中的 xy 后，正则会使用 z 和 text 中的 xy 后面的 y 比较，发现正则 z 和 y 不匹配，这时正则就会向前回溯，重新查看 y 匹配两个的情况，匹配上正则中的 xyy，然后再用 z 去匹配 text 中的 z，匹配成功。



那什么是独占模式呢，独占模式就是会尽可能的多地去匹配，如果匹配失败了就结束,不会进行回溯。实现方法即使在量词后面加上`+`

> regex = "xy{1,3}+yz"

- 缺点

某些情景无法满足，比如使用`a{1,3}+ab`去匹配`aaab`字符串，a{1,3}+会把前面三个a都用掉，并且不会回溯，这样的话最后的内容只剩下b了，会导致匹配的内容失败。

### 总结

正则中量词默认是贪婪匹配，如果想要进行非贪婪匹配需要在量词后面加上问号。贪婪和非贪婪匹配都可能会进行回溯，独占模式也是进行贪婪匹配，但不进行回溯，因此在一些场景下，可以提高匹配的效率，具体能不能用独占模式需要看使用的编程语言的类库的支持情况，以及独占模式能不能满足需求。



#### 练习题

有一篇英文文章，里面有很多单词，单词和单词之间是用空格隔开的，在引号里面的一到多个单词表示特殊含义，即引号里面的多个单词要看成一个单词。现在你需要提取出文章中所有的单词。我们可以假设文章中除了引号没有其它的标点符号，有什么方法可以解决这个问题呢？如果用正则来解决，你能不能写出一个正则，提取出文章中所有的单词呢（不要求结果去重）？

> we found “the little cat” is in the hat, we like “the little cat”
>
> 其中 the little cat 需要看成一个单词

```
(\w+)|(“.*?”)

\w+|"[^"]+"
```



