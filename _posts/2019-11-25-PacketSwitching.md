---
layout: post
title:  "分组交换网中的时延,丢包和吞吐量"
tags:   分组交换 时延 丢包 吞吐量
date:   2019-11-25 11:30:00 +0800
categories: [计算机网络]
---



理想的情况那肯定是能够在两个端系统之间瞬间移动大量数据，并且没有任何数据丢失。
当然，这是不可能滴，双十一快递都还在路上被烧掉了呢。
所以说，计算机网络要限制在端系统之间的吞吐量(每秒能够传送的数据量)，并在端系统之间引入时延的概念。丢包这种情况也会发生的。

## 1：分组交换网中的时延概述
一个分组的历程：从一个源出发，通过一系列的路由器传输，在另一个源中结束它的所有历程。我们可以将路径上的源和路由器看做结点，则分组在每一个结点都会经历几种不同类型的时延。
具体的时延分类有以下：
  - 1：**结点处理时延**(nodal processing delay)
  - 2: **排队时延**(queuing delay)
  - 3: **传输时延**(transmission delay)
  - 4：**传播时延**(propagation delay)
  - 上述几种时延加起来，引入了第五个概念：**结点总时延**(total nodal delay)


下面来具体讨论一下时延的类型：

  ![路由器A的结点时延](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-09-02/markdown-img-paste-20191119214954591.png)

上图的情景描述为：图中是源到目的地之间的端到端路径的一部分，考虑的情况是一个分组从上游结点通过路由器A向路由器B发送。
理解图中标出的路由器A处的结点时延。
  - 路由器A具有通向路由器B的链路，通向该链路之前会有一个队列(缓存)
  - 当分组从上游结点到达路由器A的时候，首先会检查该分组的首部，目的是决定该分组应该去向哪一条链路。
  - 注意：仅仅在输出链路上没有其他分组传输并且没有其他分组排在该队列的前面时，才可以在该链路上传输要传输的分组。否则的话是要排队滴。

### 处理时延
做什么操作产生的处理时延？
  - 检查分组
  - 决定将该分组导向何处
  - 检查比特级别的差错，这些差错是从上游结点向路由器A传输分组的时候带来的。

上面的操作都会消耗时间，这些时间称为处理时延

分组处理之前和处理之后有什么用？
  - 处理之后，路由器将该分组引向通往路由器B链路之前的队列。

数量级？
  - 微秒或者更低
### 排队时延
什么情况下带来排队时延？
  - 队列中，当分组在链路上等待传输的时候

排队时延受什么影响呢？
  - 取决于先期到达的正在排队等待向链路传输的分组数量。就是队列中前面排队吃鸡蛋灌饼的人数。
  - 如果队列是空的，并且没有其他分组正在传输，则排队时延为0
  - 如果流量很大，并且其他分组在等待传输，则排队时延很长

(?????到达分组期待发现的分组数量是到达该队列的流量的强度和性质的函数)
  - 这什么狗翻译，我咋没读懂

数量级？
  - 毫秒到微秒
### 传输时延
假设分组是先到先服务的方式，仅当所有已经到达的分组被传输后，才能传输刚到达的分组。

传输时延是：L/R
  - L(比特) 表示分组的长度
  - R(bps)表示从路由器A到路由器B的链路的传输速率

传输时延是将 **所有分组的比特传输向链路** 所需要的时间。

毫秒到微秒量级

### 传播时延
传播时延指什么？
  - 一旦一个比特被传输到链路，该比特需要向路由器B传播。那么从该链路的起点到路由器B传播所需要的时间是 **传播时延**

上述比特以链路的传播速率传播，取决于链路的物理媒体。

传播时延 = 两台路由器之间的距离 / 传播速率
  - d/s
  - d表示路由器A和路由器B之间的距离
  - s表示链路的传播速率

毫秒量级

### 传输时延和传播时延的比较
[zhihu](https://www.zhihu.com/question/35919386)
传输时延是路由器将 **分组推出** 所需要的时间，取决于分组的长度和链路传输速率，与两台路由器之间的距离无关。

传播时延是一个比特从一台路由器到另一台路由器传播所需要的时间，取决于两台路由器之间的距离，而与分组长度或链路的传输速率无关。

举个栗子：
  还是送快递为例，假设现在顺丰从郑州快递到沈阳，一趟是10辆车，车队不可能一下子到沈阳，中间要停下来修整，比如停在天津，秦皇岛之类的。
  那么车子到达一个站点，站点将车子服务修整好之后重新上路这段时间可以看做传输时延。
  车子从一个站点到另一个站点的时间可以看做传播时延。

d<sub>proc</sub> 处理时延；d<sub>queue</sub> 排队时延；d<sub>trans</sub> 传输时延 ；d<sub>prop</sub> 传播时延；
 d<sub>nodal</sub> = d<sub>proc</sub> +d<sub>queue</sub> +d<sub>trans</sub>+d<sub>prop</sub>

## 2：排队时延和丢包
### 排队时延
排队时延的大小受什么所影响？
  - 流量到达该队列的速率、链路的传输速率和到达流量的性质
  - 流量是周期性到达还是以突发形式到达

下面引入 **流量强度** 的概念
  - a 表示分组到达队列的平均速率(a的单位是分组/秒，即 pkt/s)
  - R为传输速率，即从队列中推出比特到传输链路的速率 b/s
  - 假定所有的分组都是由L比特组成，容易知道，比特到达队列的平均速率是La bps
  - 假定队列无限大，即可以容纳很多比特
  - 经过上述的假定，称 La/R 为 **流量强度** (traffic intensity)

流量强度有什么用？
  - 如果La/R > 1，可以看出来 比特到达队列的平均速率比比特从队列中传输到链路的速率要大，这会导致进的速率大于出的，队列不可能为空，一直增加，趋向无穷大。
  - 所以流量工程设计的一个规则：流量强度不得大于1

当La/R<=1时候呢？
  - 到达流量的性质影响排队时延
  - 1：情况1：队列周期性到达，周期性时间还是 L/R秒，这就有点太理想话了，因为这个时间刚好上一个分组被推出
  - 2：情况2：假设每（L/R）* N秒同时到达N个分组。则传输的第一个分组没有时延，但是第二个分组就有L/R时延，以此类推，第n个分组就有(n-1)* (L/R)的时延。

  ![](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-09-02/markdown-img-paste-20191120192848886.png)

但是，比特到达队列的过程是随机的，不遵循任何模式，分组之间的时间间隔是随机的。
### 丢包
上述的讨论有一条假设 “ 假定队列无限大，即可以容纳很多比特”，现实中必定不是这样。
会存在到达的分组发现队列里面没有空间了，无法存储此分组了，路由器会将此分组 **丢弃**(drop)，则此分组会 **丢失**(lost)
## 3：端到端时延
考虑从源到目的地的总时延。
  - 假设源到目的地之间有N-1台路由器
  - 假设网络此时无拥塞所以此时可忽略排队时延
  - 所以：d<sub>end-end</sub> = N(d<sub>proc</sub> + d<sub>trans</sub> + d<sub>prop</sub>)
### Traceroute
网址是：www.traceroute.org，但是我不太会用，就用了下面这个[https://tools.ipip.net/traceroute.php](https://tools.ipip.net/traceroute.php)

当我指定一个目的主机名字的时候，源主机中的该程序朝着目的地发送多个特殊的分组。这些分组会经过很多路由器来传送，当路由器接收到这些分组之一的时候，会向源会送一个短报文，该报文就包括路由器的名字和地址。

  ![](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-09-02/markdown-img-paste-20191120200017293.png)

  ![](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-09-02/markdown-img-paste-20191120200223410.png)

源会记录从它发送一个分组到它接收到对应返回报文所经受的时间。
也会记录返回该报文的路由器的名字或地址。
## 4：吞吐量
端到端的吞吐量。
如何定义吞吐量？
  - 假定主机A向主机B通过计算机网络传送一个大文件
  - 在任何时间瞬间的 **瞬时吞吐量** (instantaneous throughput)是主机B接收到该文件的速率(bps)，其实就像我们下载文件的时候，显示给我们的某个时刻的下载速度。
  - 如果文件大小为F比特，主机B接收到所有的F比特用了T秒，则 **平均吞吐量**(average throughput) 为 F/T bps

不同链路传播速度不一样，那吞吐量算谁的？
情况1：

  ![](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-09-02/markdown-img-paste-2019112020560751.png)

如上图：
  - 1：由两条通信链路和一台路由器相连，现在去考察从服务器传送文件到客户的吞吐量
  - 2：R<sub>s</sub>表示服务器与路由器之间的链路速率,R<sub>c</sub>表示路由器与客户之间的链路速率。

那么在上述情况下，服务器到客户的吞吐量是多少？不妨假设两个速率的大小，去思考文件传输的总过程。
  - 1：R<sub>s</sub> < R<sub>c</sub>，也就是说，前面慢，后面快，那就可以看做比特可以比较顺畅的传播，并以R<sub>s</sub>bps的速率给客户，所以吞吐量是R<sub>s</sub>bps
  - 2：R<sub>s</sub> < R<sub>c</sub>，即前面快，后面慢，这就会造成文件积压在路由器中

所以综上面情况1的讨论，吞吐量是min{R<sub>s</sub>,< R<sub>c</sub>}，称作 **瓶颈链路** (bottleneck link)的传输速率。
有了吞吐量之后，就容易知道传输F比特大文件所需要的时间是：F/min{R<sub>s</sub>,< R<sub>c</sub>}
  - 注意：此时还没考虑分组层次和协议的问题

情况2：不妨对情况1扩充

  ![](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-09-02/markdown-img-paste-20191120210810342.png)

同样的讨论，这种情况的吞吐量是 min{R<sub>1</sub>....< R<sub>N</sub>}

情况3：

  ![](https://raw.githubusercontent.com/ARP2019/ImageUpload/master/img/2020-09-02/markdown-img-paste-20191120211103813.png)

情况描述：
  - 同时发生10个下载，涉及10个客户-服务器对
  - 假定此时10个下载是网络中的唯一流量
  - 图中中间的链路的传输速率记为R
  - 假定所有服务器接入链路具有相同的速率R<sup>s</sup>
  - 客户接入链路具有相同的速率R<sup>c</sup>

那么此时下载的吞吐量是多少？
  - 1：如果此时公共链路的速率R很大，比R<sup>s</sup>和R<sup>c</sup>大很多，此时每个下载的吞吐量仍然是min{R<sup>s</sup>,R<sup>c</sup>}，这个例子也说明了通常限制吞吐量的是接入网，R这种一般都是高速传输的。
  - 2：假定此时R与其他两个有相同量级，不妨假设 R<sup>s</sup> =2Mbps,R<sup>c</sup>=1Mbps,R=5Mbps，并且公共链路在10个下载之间平等划分它的传输速率，则此时的瓶颈不再位于接入网，而位于核心中的共享链路，此时仅能为每个下载提供500kbps的吞吐量。
<br>
1：吞吐量取决于数据流过的链路的传输速率
2：当没其他干扰流量的时候，其吞吐量能够近似为沿着源和目的地之间路径的最小传输速率
3：吞吐量也取决于干扰流量，当许多其他数据流也通过这条链路的时候，具有高传输速率的链路仍然可能成为文件传输的瓶颈链路
